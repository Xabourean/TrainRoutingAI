# -*- coding: utf-8 -*-
"""AI_Train_Rout_Finder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yKqG0ulRs62Zwq46B1l5AdsmqLFDKOXs
"""

import haversine
import heapq
from haversine import haversine, Unit
from collections import deque

"""
NAME: Logan Daniel Sicking

Functionality:
Finds the best route between two locations based on various algorithms
Tracks the amount of steps each algorithm took to find its result
Calculates the true distance between two locations
Calculates the driving cost between  two locations based on true distance
Allows for multi route trip planning

Notes:
Utilizes the haversine formula for true distance (This is more accurate than Euclidean distance, due to accounting for the curve of the Earth)
Driving cost is calculate based on the average MPG and average gasoline price (19 pence a mile)

"""


# Create referential data for later use
def CreateNetwork(NetworkRef, NetworkCor, NetworkCon):
    # This will be used to ensure the target location is accessible
    NetworkRef = ["Manchester", "Holyhead", "Liverpool", "York", "Carlisle", "Newcastle", "Glasgow", "Edinburgh", "Oban", "Aberdeen", "Inverness"]

    # These are latitude and longitude coordinates
    Manchester = (53.4808, 2.2426)
    Holyhead = (53.3094, 4.6330)
    Liverpool = (53.4084, 2.9916)
    York = (53.9614, 1.0739)
    Carlisle = (54.8925, 2.9329)
    Newcastle = (54.9783, 1.6178)
    Glasgow = (55.8642, 4.2518)
    Edinburgh = (55.9533, 3.1883)
    Oban = (56.4152, 5.4710)
    Aberdeen = (57.1499, 2.0938)
    Inverness = (57.4778, 4.2247)

    # This stores the latitude and longitude coordinates in a usable fashion
    NetworkCor = [Manchester, Holyhead, Liverpool, York, Carlisle, Newcastle, Glasgow, Edinburgh, Oban, Aberdeen, Inverness]

    # This creates the actual train network with values for distance between each node
    NetworkCon['Manchester'] = [('Liverpool', 40), ('York', 70), ('Carlisle', 120), ('Edinburgh', 220), ('Newcastle', 140)]
    NetworkCon['Holyhead'] = [('Liverpool', 90)]
    NetworkCon['Liverpool'] = [('Holyhead', 90), ('Manchester', 40)]
    NetworkCon['York'] = [('Manchester', 70), ('Newcastle', 80)]
    NetworkCon['Carlisle'] = [('Glasgow', 100), ('Manchester', 120)]
    NetworkCon['Newcastle'] = [('York', 80), ('Manchester', 140), ('Edinburgh', 110)]
    NetworkCon['Glasgow'] = [('Oban', 100), ('Inverness', 170), ('Aberdeen', 140), ('Edinburgh', 50), ('Carlisle', 100)]
    NetworkCon['Edinburgh'] = [('Glasgow', 50), ('Manchester', 220), ('Newcastle', 110)]
    NetworkCon['Oban'] = [('Inverness', 110), ('Glasgow', 100)]
    NetworkCon['Aberdeen'] = [('Inverness', 110), ('Glasgow', 140)]
    NetworkCon['Inverness'] = [('Oban', 110), ('Glasgow', 170), ('Aberdeen', 110)]

    return NetworkRef, NetworkCor, NetworkCon


# Find the heuristic value
def heuristic(NetworkCor, NetworkRef, start, end):
    # This function utilizes the haversine formula to find the true distance between two objects on a globe
    start_index = NetworkRef.index(start)
    end_index = NetworkRef.index(end)

    return haversine(NetworkCor[start_index], NetworkCor[end_index], unit=Unit.MILES)

# Define the DFS function
def dfs(graph, start, end):
    visited = set()
    stack = [(start, [start], 0)]
    path = []
    distance = float('inf')
    # initialize step tracker
    steps = 0

    # Start the loop and run till the path is found
    while stack:
        # If the desired path is found return
        if end in path:
            return path, distance, steps
        # increment step tracker
        steps += 1
        vertex, path, distance = stack.pop()

        if vertex == end:
            if distance < distance:
                distance = distance
                path = path
        elif vertex not in visited:
            visited.add(vertex)

            for neighbor, weight in graph[vertex]:
                if neighbor not in visited:
                    stack.append((neighbor, path + [neighbor], distance + weight))

    # return step count along with path and distance
    return path, distance, steps


# Define the BFS function
def bfs(graph, start, end):
    queue = deque([(start, [start], 0)])
    visited = set()
    # initialize step tracker
    steps = 0

    # Start the loop and run till the path is found
    while queue:
        node, path, distance = queue.popleft()
        # increment step tracker
        steps += 1

        # If the desired path is found return
        if node == end:
            # return step count along with path and distance
            return path, distance, steps

        # If the desired path is not found continue
        if node not in visited:
            visited.add(node)

            # Check if the last node added leads to an acceptable path
            for neighbor, weight in graph[node]:
                if neighbor not in visited:
                    # Update the path and distance trackers
                    new_distance = distance + weight
                    new_path = path + [neighbor]
                    queue.append((neighbor, new_path, new_distance))

    # return None and step count if no path is found
    return None, None, steps


# Define the A* search function
def astar(graph, NetworkCor, NetworkRef, start, end):
    queue = [(0, start, [start], 0)]
    visited = set()
    # initialize step tracker
    steps = 0

    # Start the loop and run till the path is found
    while queue:
        _, node, path, distance = heapq.heappop(queue)
        # increment step tracker
        steps += 1

        # If the desired path is found return
        if node == end:
            # return step count along with path and distance
            return path, distance, steps

        # If the desired path is not found continue
        if node not in visited:
            visited.add(node)

            # Check if the last node added leads to an acceptable path
            for neighbor, weight in graph[node]:
                if neighbor not in visited:
                    # Update the path and distance trackers
                    new_distance = distance + weight
                    new_path = path + [neighbor]
                    # Check the heuristic and establish priority
                    h = heuristic(NetworkCor, NetworkRef, neighbor, end)
                    priority = new_distance + h
                    heapq.heappush(queue, (priority, neighbor, new_path, new_distance))

    # return None and step count if no path is found
    return None, None, steps

# Define the A* search function
def dijkstra(graph, start, end):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    queue = [(0, start)]
    previous = {node: None for node in graph}
    # initialize step tracker
    steps = 0

    # Start the loop and run till the path is found
    while queue:
        (dist, node) = heapq.heappop(queue)
        # increment step tracker
        steps += 1

        # If the desired path is found return
        if node == end:
            path = []
            total_distance = dist

            while node is not None:
                path.append(node)
                node = previous[node]

            # Reverse the path to display correctly
            path.reverse()
            # return step count along with path and distance
            return (path, total_distance, steps)

        # Tally up the distance along the path
        for neighbor, weight in graph[node]:
            new_distance = dist + weight

            if new_distance < distances[neighbor]:
                # Update the path and distance trackers
                distances[neighbor] = new_distance
                previous[neighbor] = node
                heapq.heappush(queue, (new_distance, neighbor))
                # increment step tracker
                steps += 1

    # return None and step count if no path is found
    return None, None, steps

# Define the bidirectional search function
def bidirectional_search(graph, start, end):
    start_queue = [start]
    end_queue = [end]
    # Track all the spots that have been checked on path 1
    start_visited = {start: 0}
    # Track all the spots that have been checked on path 2
    end_visited = {end: 0}
    intersect_node = None
    # initialize step and distance trackers
    steps = 0
    distance = 0

    # Start the loop and run till the path is found
    while start_queue and end_queue:
        # increment step tracker
        steps += 1
        # Explore from the start node
        curr_start = start_queue.pop(0)
        for neighbor, weight in graph[curr_start]:
            if neighbor not in start_visited:
                start_visited[neighbor] = start_visited[curr_start] + 1
                start_queue.append(neighbor)
            # if we found an intersection node
            if neighbor in end_visited:
                intersect_node = neighbor
                break
        if intersect_node:
            break

        # Explore from the end node
        curr_end = end_queue.pop(0)
        for neighbor, weight in graph[curr_end]:
            if neighbor not in end_visited:
                end_visited[neighbor] = end_visited[curr_end] + 1
                end_queue.append(neighbor)
            # if we found an intersection node
            if neighbor in start_visited:
                intersect_node = neighbor
                break
        if intersect_node:
            break

    if intersect_node is None:
        return None, steps, distance

    # Construct the final path from the start to the end node
    start_path = get_path(start, intersect_node, start_visited, graph)
    end_path = get_path(end, intersect_node, end_visited, graph)[::-1]
    final_path = start_path + end_path[1:]

    # Calculate total distance
    for i in range(len(final_path) - 1):
        for j in range(len(graph[final_path[i]])):
            if graph[final_path[i]][j][0] == final_path[i + 1]:
                distance += graph[final_path[i]][j][1]
                break

    # return step count along with path and distance
    return final_path, distance, steps

# Create a function to reconcile the two paths in the bidirectional search
def get_path(start, end, visited, graph):
    path = [end]
    curr_node = end
    while curr_node != start:
        for neighbor, weight in graph[curr_node]:
            if visited.get(neighbor) == visited.get(curr_node) - 1:
                path.append(neighbor)
                curr_node = neighbor
                break
    return path[::-1]


def main():
    # Initialize variables to be filled later
    NetworkRef = []
    NetworkCor = []
    NetworkCon = {}

    # Initialize variables for tracking the target locations
    AllStops = []
    Checker = 0

    # Fill in referential backend data
    NetworkRef, NetworkCor, NetworkCon = CreateNetwork(NetworkRef, NetworkCor, NetworkCon)

    # Get information from the user about the amount of goal nodes
    while Checker == 0:
        MultiStop = input("How many trips do you have planned?: ")
        try:
            # Ensure the user has entered a string
            MultiStop = int(MultiStop)
        except:
            print("That is not a valid answer, please try again")
        try:
            # Ensure the amount of goal nodes is a positive number
            if MultiStop > 0:
                Checker = 1
        except:
            pass

    # Get the starting position from the user
    start = input("Please enter your starting location: ")
    # Ensure the position exists within the backend data
    while start not in NetworkRef:
        print("That is not a valid location")
        start = input("Please enter your starting location: ")

    # Add the starting position to the list of all target nodes
    AllStops.append(start)

    # Ask for all the target nodes in a loop
    for x in range(MultiStop):
        stop = input("Please enter the target location: ")
        # Ensure the position exists within the backend data
        while stop not in NetworkRef:
            print("That is not a valid location")
            stop = input("Please enter the target location: ")
        # Add the target position to the list of all target nodes
        AllStops.append(stop)

    # Run the algorithms for each journey between target nodes
    for x in range(MultiStop):
        # Set the current location to the starting position for each iteration
        # Set the target location to the next node in the target list
        start = AllStops[0]
        end = AllStops[1]

        # Find the true distance between nodes
        As_The_Crow_Flies = heuristic(NetworkCor, NetworkRef, start, end)

        # Run each algorithm and receive the path, total distance, and track the steps needed
        dfs_path, dfs_distance, dfs_steps = dfs(NetworkCon, start, end)
        bfs_path, bfs_distance, bfs_steps = bfs(NetworkCon, start, end)
        a_path, a_distance, a_steps = astar(NetworkCon, NetworkCor, NetworkRef, start, end)
        dij_path, dij_distance, dij_steps = dijkstra(NetworkCon, start, end)
        bi_path, bi_distance, bi_steps = bidirectional_search(NetworkCon, start, end)

        # Print the true distance and calculate the driving cost
        # Add exception for locations unable to be driven directly from
        if start != "Holyhead" and end != "Holyhead":
            print(f"The true distance between  {start} and {end} is: {As_The_Crow_Flies:.2f}m")
            print(f"The cost for driving this distance in a car is: {(As_The_Crow_Flies * 19):.2f} pence")

        if start == "Holyhead" or end == "Holyhead":
            print(
                f"This route cannot be driven but the true distance between {start} and {end} is: {As_The_Crow_Flies:.2f}m")

        # Print the relevant data for each algorithm
        print("\nThe projected path and total distance based on the dfs algorithm is:")
        print(f"Path: {' -> '.join(dfs_path)}")
        print(f"Distance: {dfs_distance}")
        print(f"This took: {dfs_steps} steps")

        print("\nThe projected path and total distance based on the bfs algorithm is:")
        print(f"Path: {' -> '.join(bfs_path)}")
        print(f"Distance: {bfs_distance}")
        print(f"This took: {bfs_steps} steps")

        print("\nThe projected path and total distance based on the A* algorithm is:")
        print(f"Path: {' -> '.join(a_path)}")
        print(f"Distance: {a_distance}")
        print(f"This took: {a_steps} steps")

        print("\nThe projected path and total distance based on the dijkstra algorithm is:")
        print(f"Path: {' -> '.join(dij_path)}")
        print(f"Distance: {dij_distance}")
        print(f"This took: {dij_steps} steps")

        print("\nThe projected path and total distance based on the bidirectional algorithm is:")
        print(f"Path: {' -> '.join(bi_path)}")
        print(f"Distance: {bi_distance}")
        print(f"This took: {bi_steps} steps")

        # Print a separator line between trips for clarity
        print("\n ------ \n")

        # Remove the starting location for this iteration, allowing the next iteration to run smoothly
        AllStops.pop(0)


main()